# -*- coding: utf-8 -*-
"""Algo project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-naCYdcOjFMq9LGU1S0bMEZ2ycw1b3v-
"""

import numpy as np
import time
import random
from collections import defaultdict
import pandas as pd

# Python program for implementation of Quicksort Sort

# Function to find the partition position

def qs_partition(array, low, high):

	# choose a random element and swap it with the rightmost element
	pivotmark = random.randint(low,high)
	array[low], array[pivotmark] = array[pivotmark], array[high]

	# choose the rightmost element as pivot
	pivot = array[high]

	# pointer for greater element
	i = low - 1

	# traverse through all elements
	# compare each element with pivot
	for j in range(low, high):
		if array[j] <= pivot:

			# If element smaller than pivot is found
			# swap it with the greater element pointed by i
			i = i + 1

			# Swapping element at i with element at j
			(array[i], array[j]) = (array[j], array[i])

	# Swap the pivot element with the greater element specified by i
	(array[i + 1], array[high]) = (array[high], array[i + 1])

	# Return the position from where partition is done
	return i + 1

# function to perform quicksort


def quickSort(array, low, high):
	if low < high and min(array[low:high+1])!=max(array[low:high+1]):

		# Find pivot element such that
		# element smaller than pivot are on the left
		# element greater than pivot are on the right
		pi = qs_partition(array, low, high)

		# Recursive call on the left of pivot
		quickSort(array, low, pi - 1)

		# Recursive call on the right of pivot
		quickSort(array, pi + 1, high)

def callQuickSort(array):
	quickSort(array, 0, len(array)-1)

# Python3 program to perform basic timSort
MIN_MERGE = 32

def ts_calcMinRun(n):
	"""Returns the minimum length of a
	run from 23 - 64 so that
	the len(array)/minrun is less than or
	equal to a power of 2.

	e.g. 1=>1, ..., 63=>63, 64=>32, 65=>33,
	..., 127=>64, 128=>32, ...
	"""
	r = 0
	while n >= MIN_MERGE:
		r |= n & 1
		n >>= 1
	return n + r


# This function sorts array from left index to
# to right index which is of size atmost RUN
def ts_insertionSort(arr, left, right):
	for i in range(left + 1, right + 1):
		j = i
		while j > left and arr[j] < arr[j - 1]:
			arr[j], arr[j - 1] = arr[j - 1], arr[j]
			j -= 1


# Merge function merges the sorted runs
def ts_merge(arr, l, m, r):

	# original array is broken in two parts
	# left and right array
	len1, len2 = m - l + 1, r - m
	left, right = [], []
	for i in range(0, len1):
		left.append(arr[l + i])
	for i in range(0, len2):
		right.append(arr[m + 1 + i])

	i, j, k = 0, 0, l

	# after comparing, we merge those two array
	# in larger sub array
	while i < len1 and j < len2:
		if left[i] <= right[j]:
			arr[k] = left[i]
			i += 1

		else:
			arr[k] = right[j]
			j += 1

		k += 1

	# Copy remaining elements of left, if any
	while i < len1:
		arr[k] = left[i]
		k += 1
		i += 1

	# Copy remaining element of right, if any
	while j < len2:
		arr[k] = right[j]
		k += 1
		j += 1


# Iterative Timsort function to sort the
# array[0...n-1] (similar to merge sort)
def timSort(arr):
	n = len(arr)
	minRun = ts_calcMinRun(n)

	# Sort individual subarrays of size RUN
	for start in range(0, n, minRun):
		end = min(start + minRun - 1, n - 1)
		ts_insertionSort(arr, start, end)

	# Start merging from size RUN (or 32). It will merge
	# to form size 64, then 128, 256 and so on ....
	size = minRun
	while size < n:

		# Pick starting point of left sub array. We
		# are going to merge arr[left..left+size-1]
		# and arr[left+size, left+2*size-1]
		# After every merge, we increase left by 2*size
		for left in range(0, n, 2 * size):

			# Find ending point of left sub array
			# mid+1 is starting point of right sub array
			mid = min(n - 1, left + size - 1)
			right = min((left + 2 * size - 1), (n - 1))

			# Merge sub array arr[left.....mid] &
			# arr[mid+1....right]
			if mid < right:
				ts_merge(arr, left, mid, right)

		size = 2 * size

def bucketSort(array):
  """Sorts an array of integers using bucket sort."""

  # Determine the range of the input array.
  rang = max(array)-min(array)
  n = len(array)

  # Determine Bucket size based on range and array length
  bucket_size = max((rang + 1) // n, 1) # Calculate the bucket size

  # Conditions to escape recurrence
  if n <=1 or rang <= 0 or bucket_size==0:
    return array

  # Create a default dict of buckets to save memory.
  buckets = defaultdict(list)

  # Distribute the elements of the input array into the buckets.
  for element in array:
    bucket_index = element // bucket_size
    buckets[bucket_index].append(element)

  # Sort the elements within each bucket by calling bucket sort recursively.
  for idx,bucket in buckets.items():
    buckets[idx] = bucketSort(bucket)

  # Concatenate the sorted buckets together to form the sorted output array.
  sorted_array = []
  buckets = sorted(buckets.items())
  for idx,bucket in buckets:
    sorted_array.extend(bucket)

  return sorted_array

# Python program for implementation of MergeSort

# Merges two subarrays of arr[].
# First subarray is arr[l..m]
# Second subarray is arr[m+1..r]

def ms_merge(arr, l, m, r):
	n1 = m - l + 1
	n2 = r - m

	# create temp arrays
	L = [0] * (n1)
	R = [0] * (n2)

	# Copy data to temp arrays L[] and R[]
	for i in range(0, n1):
		L[i] = arr[l + i]

	for j in range(0, n2):
		R[j] = arr[m + 1 + j]

	# Merge the temp arrays back into arr[l..r]
	i = 0	 # Initial index of first subarray
	j = 0	 # Initial index of second subarray
	k = l	 # Initial index of merged subarray

	while i < n1 and j < n2:
		if L[i] <= R[j]:
			arr[k] = L[i]
			i += 1
		else:
			arr[k] = R[j]
			j += 1
		k += 1

	# Copy the remaining elements of L[], if there
	# are any
	while i < n1:
		arr[k] = L[i]
		i += 1
		k += 1

	# Copy the remaining elements of R[], if there
	# are any
	while j < n2:
		arr[k] = R[j]
		j += 1
		k += 1

# l is for left index and r is right index of the
# sub-array of arr to be sorted


def mergeSort(arr, l, r):
	if l < r:

		# Same as (l+r)//2, but avoids overflow for
		# large l and h
		m = l+(r-l)//2

		# Sort first and second halves
		mergeSort(arr, l, m)
		mergeSort(arr, m+1, r)
		ms_merge(arr, l, m, r)

def callMergeSort(arr):
  mergeSort(arr,0,len(arr)-1)

# Python program for implementation of RadixSort

def rs_counting_Sort(arr, p):
    s = len(arr)
    result = [0] * s
    c = [0] * 10

    # count of elements
    for i in range(0, s):
        index = arr[i] // p
        c[index % 10] += 1

    # cumulative count
    for i in range(1, 10):
        c[i] += c[i - 1]

    # sorted order
    i = s - 1
    while i >= 0:
        index = arr[i] // p
        result[c[index % 10] - 1] = arr[i]
        c[index % 10] -= 1
        i -= 1

    for i in range(0, s):
        arr[i] = result[i]


#  radix sort
def radixSort(arr):
    maximum = max(arr)

    p = 1
    while maximum // p > 0:
        rs_counting_Sort(arr, p)
        p *= 10

# Heap Sort in python

def heapify(arr, n, i):
    # Find largest among root and children
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[i] < arr[l]:
        largest = l

    if r < n and arr[largest] < arr[r]:
        largest = r

    # If root is not largest, swap with largest and continue heapifying
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)


def heapSort(arr):
    n = len(arr)

    # Build max heap
    for i in range(n//2, -1, -1):
        heapify(arr, n, i)

    for i in range(n-1, 0, -1):
        # Swap
        arr[i], arr[0] = arr[0], arr[i]

        # Heapify root element
        heapify(arr, i, 0)

def run_sorts(arr, name, n, k):
  results = {'name':name,'items':len(arr), 'n':n, 'k':k}

  start_time = time.time()

  arr_cpy = arr.copy()
  try:
    callQuickSort(arr_cpy)
    results['quick_sort'] = round(time.time()-start_time,4)
  except:
    results['quick_sort'] = -1


  start_time = time.time()
  arr_cpy = arr.copy()
  heapSort(arr_cpy)
  results['heap_sort'] = round(time.time()-start_time,4)

  start_time = time.time()
  arr_cpy = arr.copy()
  callMergeSort(arr_cpy)
  results['merge_sort'] = round(time.time()-start_time,4)

  start_time = time.time()
  arr_cpy = arr.copy()
  radixSort(arr_cpy)
  results['radix_sort'] = round(time.time()-start_time,4)

  start_time = time.time()
  arr_cpy = arr.copy()
  bucketSort(arr_cpy)
  results['bucket_sort'] = round(time.time()-start_time,4)


  start_time = time.time()
  arr_cpy = arr.copy()
  timSort(arr_cpy)
  results['tim_sort'] = round(time.time()-start_time,4)

  results['total_time'] = results['bucket_sort']+results['heap_sort']+results['merge_sort']\
                            +results['quick_sort']+results['radix_sort']+results['tim_sort']

  return results

rng = np.random.default_rng(seed=97202)

def random_list_1(n):
  """Creates a random list of n numbers between 0 and n."""
  arr = rng.integers(0,n+1,n)
  return arr

def random_list_2(n,k=1000):
  """Creates a random list of n numbers between 0 and k."""
  arr = rng.integers(0,k+1,n)
  return arr

def random_list_3(n):
  """Creates a random list of n numbers between 0 and n*n*n."""
  arr = rng.integers(0,n*n*n+1,n)
  return arr

def random_list_4(n):
  """Creates a random list of n numbers between 0 and log(n)."""
  arr = rng.integers(0,np.log(n)+1,n)
  return arr


def random_list_5(n):
  """Selects n random integers that are multiples of 1000 in the range 0 to n."""

  max_multiple = n // 1000
  random_indices = rng.integers(0, max_multiple + 1, n)
  arr = random_indices * 1000

  return arr

def random_list_6(n):
  """Creates a NumPy array of integers from 0 to n with log(n)/2 random swaps."""
  arr = np.arange(n + 1)  # Create an array from 0 to n

  num_swaps = int(np.log(n) // 2)  # Calculate the number of swaps

  for _ in range(num_swaps):
    indices = np.random.choice(n + 1, 2, replace=False)  # Choose two random indices
    arr[indices[0]], arr[indices[1]] = arr[indices[1]], arr[indices[0]]  # Swap values

  return arr

def run_once(n=1000, k=1000):

  results = []

  arr = random_list_1(n)
  results.append(run_sorts(arr, 'List 1', n, k))

  arr = random_list_2(n, k)
  results.append(run_sorts(arr, 'List 2', n, k))

  arr = random_list_3(n)
  results.append(run_sorts(arr, 'List 3', n, k))

  arr = random_list_4(n)
  results.append(run_sorts(arr, 'List 4', n, k))

  arr = random_list_5(n)
  results.append(run_sorts(arr, 'List 5', n, k))

  arr = random_list_6(n)
  results.append(run_sorts(arr, 'List 6', n, k))

  return results

all_results_pd = pd.DataFrame()

results = run_once(n=10000, k=1000)
results_pd = pd.DataFrame(results)

all_results_pd = pd.concat([all_results_pd,results_pd], ignore_index=True)

all_results_pd.head(30)

all_results_pd.to_csv('Algo project results.csv')

